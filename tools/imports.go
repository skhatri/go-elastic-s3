package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/skhatri/elastics3/utils"
	"log"
	"os"
	"strings"
)

func toGoType(fieldType string) string {
	gTypeName := "string"
	switch fieldType {
	case "float":
		gTypeName = "float64"
	case "int":
		gTypeName = "int"
	case "geo_point":
	case "text":
	case "key":
	case "date":
		gTypeName = "string"
	}
	return gTypeName
}

func toElasticType(fieldType string) string {
	eTypeName := "keyword"
	switch fieldType {
	case "int":
		eTypeName = "integer"
	case "string":
	case "key":
		eTypeName = "keyword"
	default:
		eTypeName = fieldType
	}
	return eTypeName
}

func main() {
	file, err := utils.Load()
	if err != nil {
		log.Fatal(err)
	}
	var cfgMap map[string]interface{}
	json.NewDecoder(file).Decode(&cfgMap)
	var schemaDef = cfgMap["schema"].(map[string]interface{})
	packageName := cfgMap["schema-package"].(string)
	typeName := cfgMap["schema-type-name"].(string)
	name := os.Args[1]
	bf := bytes.NewBufferString("// Generated by go generate\n")
	bf.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	structDef := fmt.Sprintf("type %s struct {", typeName)
	bf.WriteString(structDef)
	bf.WriteString("\n")

	properties := make([]string, 0)
	key := "id"
	for fieldName, fieldType := range schemaDef {
		fieldTypeLabel := fieldType.(string)
		var fieldParts = make([]string, 0)
		for _, p := range strings.Split(fieldName, "_") {
			fieldParts = append(fieldParts, strings.Title(p))
		}
		normalisedField := strings.Join(fieldParts, "")
		definition := fmt.Sprintf("\t%s %s `json:%q`", normalisedField, toGoType(fieldTypeLabel), fieldName)
		bf.WriteString(definition)
		bf.WriteString("\n")

		if fieldTypeLabel == "key" {
			key = normalisedField
		}

		mappingBuff := bytes.NewBufferString("")
		mappingBuff.WriteString(fmt.Sprintf("\t%q", fieldName))
		mappingBuff.WriteString(": {\n")

		elasticType := toElasticType(fieldType.(string))

		switch elasticType {
		case "text":
			mappingBuff.WriteString(fmt.Sprintf("\t\t%q: %q,\n", "type", elasticType))
			mappingBuff.WriteString(`"fields": {
				"raw": {
					"type": "keyword",
			        "normalizer": "lowercase_normalizer"
				}
			}
			`)
		case "keyword":
			mappingBuff.WriteString(fmt.Sprintf("\t\t%q: %q,\n", "type", elasticType))
			mappingBuff.WriteString(fmt.Sprintf("\t\t%q: %q\n", "normalizer", "lowercase_normalizer"))
		default:
			mappingBuff.WriteString(fmt.Sprintf("\t\t%q: %q\n", "type", elasticType))
		}
		mappingBuff.WriteString("\t}")
		properties = append(properties, mappingBuff.String())
	}
	structEnd := "}"
	bf.WriteString(structEnd)
	bf.WriteString("\n")

	bf.WriteString(fmt.Sprintf("func (t *%s) GetKey() string {\n\treturn t.%s\n}\n", typeName, key))

	mappingStart := `{
"dynamic": "false",
"properties": {
`

	mappingEnd := `}
    }
	`
	bf.WriteString("\nvar MappingText=`")
	bf.WriteString(mappingStart)
	bf.WriteString(strings.Join(properties, ",\n"))
	bf.WriteString("\n")
	bf.WriteString(mappingEnd)
	bf.WriteString("`\n")

	fileName := fmt.Sprintf("%s/%s.go", packageName, strings.ToLower(name))
	err = os.MkdirAll(packageName, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
	schemaFile, err := os.Create(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer schemaFile.Close()
	schemaFile.WriteString(bf.String())

}
